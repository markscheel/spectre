// Distributed under the MIT License.
// See LICENSE.txt for details.

#pragma once

#include <memory>

#include "DataStructures/TempBuffer.hpp"
#include "Options/Options.hpp"
#include "PointwiseFunctions/AnalyticData/AnalyticData.hpp"
#include "PointwiseFunctions/AnalyticData/GrMhd/AnalyticData.hpp"
#include "PointwiseFunctions/GeneralRelativity/Tags.hpp"
#include "PointwiseFunctions/Hydro/EquationsOfState/EquationOfState.hpp"
#include "PointwiseFunctions/Hydro/Tags.hpp"
#include "PointwiseFunctions/InitialDataUtilities/InitialData.hpp"
#include "Utilities/Serialization/CharmPupable.hpp"
#include "Utilities/TMPL.hpp"
#include "Utilities/TaggedTuple.hpp"

/// \cond
namespace PUP {
class er;
}  // namespace PUP
namespace spec {
class Exporter;
}  // namespace spec
/// \endcond

namespace grmhd::AnalyticData {

/*!
 * \brief Initial data generated by SpEC.
 */
class SpecInitialData : public evolution::initial_data::InitialData,
                        public MarkAsAnalyticData,
                        public AnalyticDataBase {
 public:
  using equation_of_state_type = EquationsOfState::EquationOfState<true, 1>;

  struct DataDirectory {
    using type = std::string;
    static constexpr Options::String help = {
        "Path to a directory of data produced by SpEC. The directory is "
        "expected to contain 'GrDomain.input' and 'Vars*.h5' files for all the "
        "subdomains in GrDomain.input."};
  };

  using options =
      tmpl::list<DataDirectory, hydro::OptionTags::EquationOfState<true, 1>>;

  static constexpr Options::String help = {"Initial data generated by SpEC"};

  SpecInitialData() = default;
  SpecInitialData(const SpecInitialData& /*rhs*/) = delete;
  SpecInitialData& operator=(const SpecInitialData& /*rhs*/) = delete;
  SpecInitialData(SpecInitialData&& /*rhs*/) = default;
  SpecInitialData& operator=(SpecInitialData&& /*rhs*/) = default;
  ~SpecInitialData();

  SpecInitialData(std::string data_directory,
                  std::unique_ptr<equation_of_state_type> equation_of_state);

  auto get_clone() const
      -> std::unique_ptr<evolution::initial_data::InitialData> override;

  /// \cond
  explicit SpecInitialData(CkMigrateMessage* msg);
  using PUP::able::register_constructor;
  WRAPPED_PUPable_decl_template(SpecInitialData);
  /// \endcond

  template <typename DataType, typename... Tags>
  tuples::TaggedTuple<Tags...> variables(const tnsr::I<DataType, 3>& x,
                                         tmpl::list<Tags...> /*meta*/) const {
    auto interpolated_vars = interpolate_from_spec(x);
    return {std::move(get<Tags>(interpolated_vars))...};
  }

  const equation_of_state_type& equation_of_state() const {
    return *equation_of_state_;
  }

  // NOLINTNEXTLINE(google-runtime-references)
  void pup(PUP::er& /*p*/) override;

 private:
  template <typename DataType>
  using interpolated_tags =
      tmpl::list<gr::Tags::SpatialMetric<3, Frame::Inertial, DataType>,
                 gr::Tags::ExtrinsicCurvature<3, Frame::Inertial, DataType>,
                 gr::Tags::Lapse<DataType>,
                 gr::Tags::Shift<3, Frame::Inertial, DataType>>;
  template <typename DataType>
  tuples::tagged_tuple_from_typelist<interpolated_tags<DataType>>
  interpolate_from_spec(const tnsr::I<DataType, 3>& x) const;

  std::string data_directory_;
  std::unique_ptr<equation_of_state_type> equation_of_state_;

  std::vector<std::string> vars_to_interpolate_{
      "Nid_g",     // (lower 3-metric)
      "Nid_K",     // (lower extrinsic curvature)
      "Nid_N",     // (lapse function)
      "Nid_Shift"  // (upper shift vector)
  };
  std::unique_ptr<spec::Exporter> spec_exporter_;
};

}  // namespace grmhd::AnalyticData
